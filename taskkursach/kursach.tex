\documentclass[bachelor, och, coursework]{SCWorks}

\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{srcltx}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{tempora}
\usepackage{fancyvrb}
\usepackage{minted}

\setminted{linenos=true, numbersep=5pt, breaklines}
\usemintedstyle{bw}

\usepackage[colorlinks=false]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\graphicspath{pics}


\begin{document}

\section{Абстрактные синтаксические деревья}

\subsection{Мотивировка}

Несмотря на то, что программа работает корректно, в ней присутствует
достаточно много недостатков. А именно:
\begin{enumerate}
    \item Изменение и улучшение программы невозможно без затрагивания ее функциональности.
    \item Невозможно повторное использование уже полученных лексическим анализатором данных.
    \item Использования возможностей только КС"=грамматики может быть недостаточно для решения поставленной задачи.
\end{enumerate}
Эти и некоторые другие задачи позволяет решить концепция абстрактных синaтаксических деревьев.

\subsection{Определение}

Абстрактное синтаксическое дерево (АСД) --- конечное помеченное ориентированное дерево, 
в котором внутренние вершины сопоставлены с операторами языка программирования, а листья --- с соответствующими операндами\cite{asd}.

Рассмотрим выражение $1+2*3$. Вид синтаксического дерева для такого
выражения изображен на рис. \hyperref[fig:abstree]{1}:

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.45]{pics/ast.png}
    \caption{Пример абстрактного синтаксического дерева}\label{fig:abstree}
\end{figure}

Обход такого дерева для получения результата достаточно интуитивен:
достаточно обойти дерево начиная с листьев, последовательно вычисляя значения в вершинах, соответствующих математическим операторам.

\subsection{Построение}

\subsubsection{Определение структуры данных}

Для построения абстрактного синтаксического дерева в рамках нашей
задачи потребуются описание некоторой структуры данных, хранящей наши
узлы.

В качестве узла возьмем структуру, хранящую тип вершины и указатели на
дочерние элементы. Нам будет вполне достаточно иметь две вершины в качестве
дочерних, так как мы имеем дело исключительно с унарными и бинарными
операторами.

Таким образом, получим следующий вид структуры:

\begin{minted}[fontsize=\small]{c}
typedef struct node {
    // Тип ячейки
    int nodetype;
    // Указатель на "левый" дочерний элемент
    struct node* l;
    // Указатель на "правый" дочерний элемент
    struct node* r;
} node;
\end{minted}
Листья не содержат дочерних элементов, поэтому реализуем отдельную струк-
туру данных под хранение листовых элементов дерева:

\begin{minted}[fontsize=\small]{c}
typedef struct value {
    // Тип ячейки
    int nodetype;
    // Численное значение ячейки
    double number;
} value;
\end{minted}

\subsubsection{Построение дерева}

Теперь необходимо реализовать функции newnum и newast, которые будут
осуществлять создания узлов для чисел (в рамках дерева представляющих из
себя исключительно листья) и для узлов, содержащих операторы.

Получим следующую реализацию функции newast:

\begin{minted}[fontsize=\small]{c}
struct node* newast(int nodetype, struct node* l, struct node* r) {
    // Выделяем память стандартной функцией malloc
    struct node* a = malloc(sizeof(struct node));]
    // Проверяем, была ли память выделена
    if (!a) {
    yyerror("Not enough memory" );
    exit(0);
    }
    // Инициализируем поля нужными значениями
    a->nodetype = nodetype;
    a->l = l;
    a->r = r;
    return a;
\end{minted}

Аналогичным образом реализуем функцию newnum:

\begin{minted}[fontsize=\small]{c}
struct node* newnum(double d) {
    // Выделяем память стандартной функцией
    struct value* a = malloc(sizeof(struct value));
    // Проверяем, была ли память выделена
    if(!a) {
    yyerror("Not enough memory" );
    exit(0);
    }
    // Инициализируем поля
    a->nodetype = 'K' ;
    a->number = d;
    // Возвращаем приведенный к типу node* указатель
    return (struct node*) a;
}
\end{minted}
Отметим, что в данном случае результатом функции является приведенный к
node* указатель на вершину с номером. В дальнейшем мы будем это учитывать,
приводя, где необходимо, указатель обратно к указателю на value*.

\subsubsection{Обход полученного АСД}

Заметим, что для вычисления результатов необходимо выполнить обход
дерева, получив значение в корне дерева. Для этого реализуем функцию eval.
Функция будет представлять из себя рекурсивный вызов от левого и правого
поддеревьев до тех пор, пока не будет найден лист. Получим следующий код:

\begin{minted}[fontsize=\small]{c}
double eval (arena* arena, struct node* a) {
    double v;
    unsigned int type = a->nodetype;
    node* block = arena->arena;
    // Выполняем действия в зависимости от типа узла
    switch (type) {
    case 'K' : {
        value* val = (value*) a;
        v = val->number;
        break;
    }
    case '+' :
        v = eval(arena, block + a->l) + eval(arena, block + a->r);
        break;
    case '-' :
        v = eval(arena, block + a->l) - eval(arena, block + a->r);
        break;
    case '*' :
        v = eval(arena, block + a->l) * eval(arena, block + a->r);
        break;
    case '/' :
        v = eval(arena, block + a->l) / eval(arena, block + a->r);
        break;
    case '|' :
        v = fabs(eval(arena, block + a->l));
        break;
    case 'M' :
        v = -eval(arena, block + a->l);
        break;
    default:
        printf("internal error: bad node %c \n " , a->nodetype);
        break;
    }
    return v;
}
\end{minted}
Запуск такой функции от корня позволит рекурсивно прямым обходом пройти
полученное дерево и получить искомый результат.

\subsubsection{Освобождение выделенной памяти}

Наконец, реализуем функцию treefree освобождения памяти нашего абстрактного синтаксического дерева:

\begin{minted}[fontsize=\small]{c}
void treefree(struct node* a) {
    // В зависимости от числа дочерних элементов выполняем рекурсивное освобождение памяти
    if (a->nodetype == '+' || a->nodetype == '-' || a->nodetype == '*' || a->nodetype == '/' ) {
        treefree(a->r);
        treefree(a->l);
        free(a);
    }
    else
    if (a->nodetype == '|' || a->nodetype == 'M' ) {
        treefree(a->l);
        free(a);
    }
    else
    if (a->nodetype == 'K' ) {
        free(a);
    }
    else {
        printf("internal error: free bad node %c \n " , a->nodetype);
    }
}
\end{minted}

\subsubsection{Модификация программы анализатора}

Осталось лишь сообщить GNU Bison, каким образом обращаться к нашей
структуре данных. Изменим содержимое второго блока и получим следующую
реализацию:

\begin{minted}[fontsize=\small]{c}
%{
#include <stdio.h>
#include <stdlib.h>
// Добавим подключение заголовочного файла, содержащего описание нашей структуры данных
#include "ast.h"
int yylex();
int yyparse();
%}
// Укажем, что одним из возможных значений элемента стека может быть указатель на нашу структуру данных
%union {
    struct node* a;
    double d;
}

%token <d> NUMBER
%token EOL

%left '+' '-'
%left '*' '/'
%nonassoc '|' UMINUS

// Укажем, что нетерминал exp представляет из себя указатель на node*
%type <a> exp

%%

calclist:
    // Если дерево построено - необходимо обойти его и вывести результат, после чего освободить память
    | calclist exp EOL { printf("= %f \n " , eval($2));
    treefree($2);
    printf("> " );
    }
    | calclist EOL { printf("> " ); }
;
// Иначе если мы применяем одно из правил - построим новый узел в соответствии с правилом
exp: exp '+' exp {$$ = newast('+' , $1, $3); }
    | exp '-' exp {$$ = newast('-' , $1, $3); }
    | exp '*' exp {$$ = newast('*' , $1, $3); }
    | exp '/' exp {$$ = newast('/' , $1, $3); }
    | '|' exp {$$ = newast('|' , $2, NULL); }
    | '(' exp ')' {$$ = $2; }
    | '-' exp %prec UMINUS { $$ = newast('M' , $2, NULL); }
    | NUMBER {printf("%c" , $1);$$ = newnum($1); }
;

%%


int main(int argc, char** argv) {
    printf("> " );
    return yyparse();
}

void yyerror(char* s) {
    fprintf(stderr, "%d: error: " , yylineno);
    fprintf(stderr, " \n " );
}
\end{minted}
Полученную программу можно собрать, воспользовавшись вызовом make над
модифицированным Makefile:

\begin{minted}[fontsize=\small]{c}
calc.out: calc.l calc.y ast.h
    bison -d calc.y
    flex calc.l
    cc -o $@ calc.tab.c lex.yy.c ast.c
\end{minted}
после чего запустить.

Результат работы программы представлен на рис. \hyperref[fig:res1]{2}:
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{pics/naivetest.png}
    \caption{Демонстрация работы программы}\label{fig:res1}
\end{figure}

Как мы позже увидим, текущая версия значительно производительнее
версии без абстрактного синтаксического дерева.

\subsection{Управление памятью на основе регионов}

\subsubsection{Мотивировка}

Текущая реализация абстрактного синтаксического дерева имеет следующие недостатки:
\begin{enumerate}
    \item Выделение памяти стандартным методом может значительно фрагментировать оперативную память, затрудняя доступ к ней.
    \item Любое выделение и удаление памяти требует вмешательства системных вызовов, что может стать причиной дополнительных издержек во время работы программы.
    \item Программист не имеет возможности ручного управления выделяемой им памятью.
\end{enumerate}
 
Избавиться от этих недостатков можно используя различные оптимизации. В рамках этой работы воспользуемся управлением памятью на основе, так
называемых, регионов (арен, зон)\cite{wang}.

Под регионом далее будем понимать непрерывную область памяти, содер-
жащую внутри себя объекты. При запуске программы выделим регион некоторо-
го размера, при необходимости увеличивая его размер в некоторое постоянное
число раз.

Этот подход имеет следующие преимущества:
\begin{enumerate}
    \item Элементы располагаются последовательно, в связи с чем минимизируется фрагментация и упрощается доступ к объектам.
    \item Выделение и освобождение памяти выполняется с минимальными издержками.
    \item Программисту предоставляется большая свобода для управления выделенной памятью.
\end{enumerate}

\subsubsection{Построение}

Формально определим требования к системе:
\begin{enumerate}
    \item Регион должен представлять из себя некоторый непрерывный участок размера $n$ байт (в начальный момент времени размер равен некоторой начальной величине $n_0$).
    \item При обращении к региону он должен предоставить $k$ байт памяти и вернуть некоторый идентификатор этого участка для последующего обращения.
    \item При заполнении региона должна быть возможность увеличить объем доступной памяти в некоторое число раз, которое далее будем называть коэффициентом увеличения.
    \item Должна быть доступна возможность эффективного освобождения всей выделенной регионом памяти.
\end{enumerate}

Единственной сложной операцией над регионом является его увеличение.
Так как выделение нового участка потенциально может сопровождаться изменением адресов объектов, то необходимо организовать доступ к ним независимо от первоначального адреса. Для этого для каждого объекта будем получать
доступ к нему через некоторый индекс.

Кроме того, коэффициент увеличения должен быть выбран таким обра-
зом, чтобы был соблюден баланс между оптимальным объемом выделенной
памяти и частотой системных вызовов.

\subsubsection{Определение структуры}

Определим нашу структуру следующим образом:

\begin{minted}[fontsize=\small]{c}
typedef struct arena {
    // Указатель на начало региона
    struct node* arena;
    // Размер региона
    unsigned int size;
    // Объем выделенной регионом памяти
    unsigned int allocated;
} arena;
\end{minted}

\subsubsection{Инициализация}

Теперь определим функцию \texttt{arena\_construct}, выполняющую начальную
инициализацию состояния региона:

\begin{minted}[fontsize=\small]{c}
int arena_construct (arena* arena) {
    // Начальный размер региона равен некоторой постоянной, равной DEFAULT_ARENA_SIZE
    arena->size = DEFAULT_ARENA_SIZE;
    arena->allocated = 0;
    // Выделим необходимое число памяти
    arena->arena = malloc(sizeof(node) * DEFAULT_ARENA_SIZE);
    // Если выделение прошло неудачно - вернем в качестве кода ошибки отличное от 0 значение.
    if (arena->arena == NULL) {
        return (!0);
    }
    return 0;
}
\end{minted}

\subsubsection{Выделение памяти}

После выделения некоторого объема памяти возможно обращение к ней.
Определим это обращение с помощью функции texttt{arena\_allocate}:

\begin{minted}[fontsize=\small]{c}
int arena_allocate (arena* arena, unsigned int count) {
    // Если места в регионе недостаточно
    if (arena->allocated + count >= arena->size) {
        // Определим новый размер региона
        unsigned int newSize = MULTIPLY_FACTOR * arena->size;
        // Выделим регион большего размера и освободим ранее занятую память
        node* newArena = realloc(arena->arena,
            newSize * sizeof(node));
        if (NULL == newArena) {
            return -1;
        }
        arena->arena = newArena;
        arena->size = newSize;
    }
    // В качестве результата вернем индекс первого свободного участка региона
    unsigned int result = arena->allocated;
    // Сместим индекс на объем выделенной памяти
    arena->allocated += count;
    // Вернем результат
    return result;
}
\end{minted}
Отметим, что наиболее часто значением \texttt{MULTIPLY\_FACTOR} оказывается числа
\texttt{1.5} и \texttt{2}. Это позволяет достичь амортизационно константного времени выпол-
нения операции выделения памяти\cite{facebook}.

\subsubsection{Освобождение выделенной памяти}

Наконец, реализуем освобождение выделенной региону памяти с помощью функции \texttt{arena\_free}

\begin{minted}[fontsize=\small]{c}
void arena_free (arena* arena) {
    if (arena->arena != NULL)
        free(arena->arena);
    arena->arena = NULL;
}
\end{minted}

\subsubsection{Модификация абстрактного синтаксического дерева}

Осталось изменить исходный код программы, чтобы обеспечить выделение памяти с помощью полученной нами структуры данных.

Для этого воспользуемся директивой \texttt{\%param} и заявим в качестве параметра переменную типа \texttt{arena*}. В функциях \texttt{eval, newnum, newast} внесем изменения, чтобы обеспечить выделение памятью с помощью написанных ранее
функций.

С полным кодом программы можно ознакомиться в приложении \hyperref[app:A]{A}.

\subsubsection{Сборка проекта}

Теперь проект можно собрать, незначительно изменив \texttt{Makefile}:

\begin{minted}[fontsize=\small]{c}
calc.out: calc.l calc.y arena_ast.h
    bison -d calc.y
    flex calc.l
    cc -o $@ calc.tab.c lex.yy.c arena_ast.c arena.c
\end{minted}
и запустить. Результат работы программы представлен на рис. \hyperref[fig:res2]{3}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{pics/naivetest.png}
    \caption{Демонстрация работы программы}\label{fig:res2}
\end{figure}

\section{Сравнение полученных реализаций}

Проведем анализ производительности полученных версий анализатора. 
В качестве данных для тестирования возьмем выражения вида 
$\underbrace{2+2+\dots+2}_{n}$ 
для $n=1\dots100$ с шагом \texttt{1}. Для вычисления времени выполнения воспользуемся библиотекой \texttt{time} Python 3.9.5. Автоматизацию обеспечим с помощью
библиотеки \texttt{subprocess}. Получим следующий код:

\begin{minted}[fontsize=\small]{py}
import subprocess as sb
import time
import sys
def run(args):
    return sb.run(args,
        capture_output=True, ).stdout.decode().strip()

def main():
    if (len(sys.argv) < 6):
        print("Invalid arguments" )
        return
    exe_path = sys.argv[1]
    out_path = sys.argv[2]
    right_bound = int(sys.argv[3])
    step = int(sys.argv[4])
    iter = sys.argv[5]

    f = open(out_path, "w" )
    f.write(f " { exe_path} \n " )
    f.close()
    for expr_len in range(1, right_bound, step):
        test_string = "+" .join(['2' ] * expr_len)
        args = [exe_path, test_string, iter]
        t = time.monotonic()
        run(args)
        end_t = time.monotonic()
        f = open(out_path, "a" )
        f.write(f " { expr_len} { (end_t - t) / (int(iter))} \n " )
        f.close()
        print(f " Step { expr_len} finished" )

if __name__ == "__main__" :
    main()
\end{minted}

Кроме того, отметим, что в ранее написанные программы были внесены некоторые изменения для проведения эксперимента. Ознакомиться с ними
можно в приложении \hyperref[app:A]{A}.

Ознакомиться с полным исходным кодом программы, осуществляющей
исследование производительности можно в приложении \hyperref[app:B]{Б}.

Для большей наглядности графики интерполированы полиномом с помощью функции \texttt{polyfit} библиотеки \texttt{numpy}.

Ознакомиться с полным исходным кодом программы, осуществляющей
анализ полученных результатов можно в приложении \hyperref[app:C]{В}.

Результаты исследования изображены на рис. \hyperref[fig:graf]{4}:

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{pics/benchmark.png}
    \caption{Сравнение полученных результатов}\label{fig:graf}
\end{figure}

Исследование показало, что использование абстрактных синтаксических
деревьев позволяет уменьшить время работы программы более чем в \texttt{5} раз, что
существенно заметно для выражений любой длины.

Также из графиков видно, что в рамках данной работы не удалось добиться большей производительности при управлении памятью на основе регионов.
Тем не менее, она все еще может считаться более предпочительной ввиду перечисленных ранее преимуществ.

\conclusion

В ходе данной работы:
\begin{enumerate}
    \item Были изучены теоретические основы построения лексических и синтаксических анализаторов.
    \item Проанализированы особенности реализации лексических и синтаксических анализаторов.
    \item Были изучены принципы работы генераторов лексического и синтаксического анализа на примере Flex и GNU Bison.
    \item Были созданы лексический и синтаксический анализаторы для анализа математического выражения.
    \item Было изучено понятие абстрактного синтаксического дерева.
    \item Проведен анализ производительности полученных реализаций.
\end{enumerate}

Таким образом, все поставленные в рамках работы задачи выполнены.

Результаты исследования показали, что абстрактные синтаксические деревья позволяют добиться увеличения производительности в \texttt{5--6} раз.

А это, в свою очередь, позволяет утверждать о том, что концепция абстрактных синтаксических деревьев является крайне важной в информатике и
ее приложениях, в частности, при создании синтаксических анализаторов.

\bibliographystyle{gost780uv}
\bibliography{source}

\appendix

\section{Flash"=носитель с исходным кодом программ, использующихся в работе}
\label{app:A}
\noindent\textbf{Папка} \texttt{src} содержит оригинальный исходный код программы:

\textbf{Папка} \texttt{naive} --- реализация без АСД

\textbf{Папка} \texttt{naiveast} --- реализация с АСД

\textbf{Папка} \texttt{arena} --- реализация с АСД на основе региона

\noindent\textbf{Папка} \texttt{extsrc} содержит измененный исходный код, необходимый для исследования производительности:

\textbf{Папка} \texttt{naive} --- реализация без АСД

\textbf{Папка} \texttt{naiveast} --- реализация с АСД

\textbf{Папка} \texttt{arena} --- реализация с АСД на основе региона

\section{Исходный код программы на Python, осуществляющей исследование производительности полученных реализаций}
\label{app:B}
\begin{minted}[fontsize=\small]{py}
import subprocess as sb
import time
import sys
def run(args):
    return sb.run(args,
        capture_output=True, ).stdout.decode().strip()

def main():
    if (len(sys.argv) < 6):
        print("Invalid arguments" )
        return
    exe_path = sys.argv[1]
    out_path = sys.argv[2]
    right_bound = int(sys.argv[3])
    step = int(sys.argv[4])
    iter = sys.argv[5]

    f = open(out_path, "w" )
    f.write(f " { exe_path} \n " )
    f.close()
    for expr_len in range(1, right_bound, step):
        test_string = "+" .join(['2' ] * expr_len)
        args = [exe_path, test_string, iter]
        t = time.monotonic()
        run(args)
        end_t = time.monotonic()
        f = open(out_path, "a" )
        f.write(f " { expr_len} { (end_t - t) / (int(iter))} \n " )
        f.close()
        print(f " Step { expr_len} finished" )

if __name__ == "__main__" :
    main()
\end{minted}

\section{Исходный код программы на Python, осуществляющей анализ полученных результатов}
\label{app:C}
\begin{minted}[fontsize=\small]{py}
import subprocess as sb
from time import time
import matplotlib.pyplot as plt
import sys
import numpy as np

legend = []
for index in range(1, len(sys.argv)):
    file_name = sys.argv[index]
    f = open(file_name, "r" )
    try:
        parser_type = f.readline()
    except StopIteration:
        parser_type = "Undefined parser"
    legend.append(parser_type)

    x_axis = []
    y_axis = []
    for line in f:
        try:
            w, h = [float(x) for x in next(f).split()]
        except StopIteration:
            break
        x_axis.append(w)
        y_axis.append(h)
    plt.xlabel("Длина выражения" , size = 22)
    plt.ylabel("Время" , size = 22)
    p = np.polyfit(x_axis, y_axis, 1)
    for i in range(len(x_axis)):
        y_axis[i] = p[0] * x_axis[i] + p[1]

    plt.plot(x_axis, y_axis)
plt.xlim(0.5, 100.5)
plt.ylim(5e-8, 2e-5)
plt.rcParams.update({'font.size': 18})
#plt.yscale("log")
plt.grid(True)
plt.legend(legend, loc="lower right" )
plt.show()
\end{minted}
\end{document}