\documentclass[bachelor, och, coursework]{SCWorks}

\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{srcltx}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{tempora}
\usepackage{fancyvrb}
\usepackage{minted}

\setminted{linenos=true, numbersep=5pt, breaklines}
%\usemintedstyle{bw}

\usepackage[colorlinks=false]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\graphicspath{pics}


\begin{document}

\section{Абстрактные синтаксические деревья}

\subsection{Мотивировка}

Несмотря на то, что программа работает корректно, в ней присутствует
достаточно много недостатков. А именно:
\begin{enumerate}
    \item Изменение и улучшение программы невозможно без затрагивания ее функциональности.
    \item Невозможно повторное использование уже полученных лексическим анализатором данных.
    \item Использования возможностей только КС"=грамматики может быть недостаточно для решения поставленной задачи.
\end{enumerate}
Эти и некоторые другие задачи позволяет решить концепция абстрактных синaтаксических деревьев.

\subsection{Определение}

Абстрактное синтаксическое дерево (АСД) --- конечное помеченное ориентированное дерево, 
в котором внутренние вершины сопоставлены с операторами языка программирования, а листья --- с соответствующими операндами\cite{asd}.

Рассмотрим выражение $1+2*3$. Вид синтаксического дерева для такого
выражения изображен на рис. \hyperref[fig:abstree]{1}:

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.45]{pics/ast.png}
    \caption{Пример абстрактного синтаксического дерева}\label{fig:abstree}
\end{figure}

Обход такого дерева для получения результата достаточно интуитивен:
достаточно обойти дерево начиная с листьев, последовательно вычисляя значения в вершинах, соответствующих математическим операторам.

\subsection{Построение}

\subsubsection{Определение структуры данных}

Для построения абстрактного синтаксического дерева в рамках нашей
задачи потребуются описание некоторой структуры данных, хранящей наши
узлы.

В качестве узла возьмем структуру, хранящую тип вершины и указатели на
дочерние элементы. Нам будет вполне достаточно иметь две вершины в качестве
дочерних, так как мы имеем дело исключительно с унарными и бинарными
операторами.

Таким образом, получим следующий вид структуры:

\begin{minted}[fontsize=\small]{c}
typedef struct node {
    // Тип ячейки
    int nodetype;
    // Указатель на "левый" дочерний элемент
    struct node* l;
    // Указатель на "правый" дочерний элемент
    struct node* r;
} node;
\end{minted}
Листья не содержат дочерних элементов, поэтому реализуем отдельную струк-
туру данных под хранение листовых элементов дерева:

\begin{minted}[fontsize=\small]{c}
typedef struct value {
    // Тип ячейки
    int nodetype;
    // Численное значение ячейки
    double number;
} value;
\end{minted}

\subsubsection{Построение дерева}

Теперь необходимо реализовать функции newnum и newast, которые будут
осуществлять создания узлов для чисел (в рамках дерева представляющих из
себя исключительно листья) и для узлов, содержащих операторы.

Получим следующую реализацию функции newast:

\begin{minted}[fontsize=\small]{c}
struct node* newast(int nodetype, struct node* l, struct node* r) {
    // Выделяем память стандартной функцией malloc
    struct node* a = malloc(sizeof(struct node));]
    // Проверяем, была ли память выделена
    if (!a) {
    yyerror("Not enough memory" );
    exit(0);
    }
    // Инициализируем поля нужными значениями
    a->nodetype = nodetype;
    a->l = l;
    a->r = r;
    return a;
\end{minted}

Аналогичным образом реализуем функцию newnum:

\begin{minted}[fontsize=\small]{c}
struct node* newnum(double d) {
    // Выделяем память стандартной функцией
    struct value* a = malloc(sizeof(struct value));
    // Проверяем, была ли память выделена
    if(!a) {
    yyerror("Not enough memory" );
    exit(0);
    }
    // Инициализируем поля
    a->nodetype = 'K' ;
    a->number = d;
    // Возвращаем приведенный к типу node* указатель
    return (struct node*) a;
}
\end{minted}
Отметим, что в данном случае результатом функции является приведенный к
node* указатель на вершину с номером. В дальнейшем мы будем это учитывать,
приводя, где необходимо, указатель обратно к указателю на value*.

\subsubsection{Обход полученного АСД}

Заметим, что для вычисления результатов необходимо выполнить обход
дерева, получив значение в корне дерева. Для этого реализуем функцию eval.
Функция будет представлять из себя рекурсивный вызов от левого и правого
поддеревьев до тех пор, пока не будет найден лист. Получим следующий код:

\begin{minted}[fontsize=\small]{c}
double eval (arena* arena, struct node* a) {
    double v;
    unsigned int type = a->nodetype;
    node* block = arena->arena;
    // Выполняем действия в зависимости от типа узла
    switch (type) {
    case 'K' : {
        value* val = (value*) a;
        v = val->number;
        break;
    }
    case '+' :
        v = eval(arena, block + a->l) + eval(arena, block + a->r);
        break;
    case '-' :
        v = eval(arena, block + a->l) - eval(arena, block + a->r);
        break;
    case '*' :
        v = eval(arena, block + a->l) * eval(arena, block + a->r);
        break;
    case '/' :
        v = eval(arena, block + a->l) / eval(arena, block + a->r);
        break;
    case '|' :
        v = fabs(eval(arena, block + a->l));
        break;
    case 'M' :
        v = -eval(arena, block + a->l);
        break;
    default:
        printf("internal error: bad node %c \n " , a->nodetype);
        break;
    }
    return v;
}
\end{minted}
Запуск такой функции от корня позволит рекурсивно прямым обходом пройти
полученное дерево и получить искомый результат.

\subsubsection{Освобождение выделенной памяти}

Наконец, реализуем функцию treefree освобождения памяти нашего абстрактного синтаксического дерева:

\begin{minted}[fontsize=\small]{c}
void treefree(struct node* a) {
    // В зависимости от числа дочерних элементов выполняем рекурсивное освобождение памяти
    if (a->nodetype == '+' || a->nodetype == '-' || a->nodetype == '*' || a->nodetype == '/' ) {
        treefree(a->r);
        treefree(a->l);
        free(a);
    }
    else
    if (a->nodetype == '|' || a->nodetype == 'M' ) {
        treefree(a->l);
        free(a);
    }
    else
    if (a->nodetype == 'K' ) {
        free(a);
    }
    else {
        printf("internal error: free bad node %c \n " , a->nodetype);
    }
}
\end{minted}

\subsubsection{Модификация программы анализатора}

Осталось лишь сообщить GNU Bison, каким образом обращаться к нашей
структуре данных. Изменим содержимое второго блока и получим следующую
реализацию:

\begin{minted}[fontsize=\small]{c}
%{
#include <stdio.h>
#include <stdlib.h>
// Добавим подключение заголовочного файла, содержащего описание нашей структуры данных
#include "ast.h"
int yylex();
int yyparse();
%}
// Укажем, что одним из возможных значений элемента стека может быть указатель на нашу структуру данных
%union {
    struct node* a;
    double d;
}

%token <d> NUMBER
%token EOL

%left '+' '-'
%left '*' '/'
%nonassoc '|' UMINUS

// Укажем, что нетерминал exp представляет из себя указатель на node*
%type <a> exp

%%

calclist:
    // Если дерево построено - необходимо обойти его и вывести результат, после чего освободить память
    | calclist exp EOL { printf("= %f \n " , eval($2));
    treefree($2);
    printf("> " );
    }
    | calclist EOL { printf("> " ); }
;
// Иначе если мы применяем одно из правил - построим новый узел в соответствии с правилом
exp: exp '+' exp {$$ = newast('+' , $1, $3); }
    | exp '-' exp {$$ = newast('-' , $1, $3); }
    | exp '*' exp {$$ = newast('*' , $1, $3); }
    | exp '/' exp {$$ = newast('/' , $1, $3); }
    | '|' exp {$$ = newast('|' , $2, NULL); }
    | '(' exp ')' {$$ = $2; }
    | '-' exp %prec UMINUS { $$ = newast('M' , $2, NULL); }
    | NUMBER {printf("%c" , $1);$$ = newnum($1); }
;

%%


int main(int argc, char** argv) {
    printf("> " );
    return yyparse();
}

void yyerror(char* s) {
    fprintf(stderr, "%d: error: " , yylineno);
    fprintf(stderr, " \n " );
}
\end{minted}
Полученную программу можно собрать, воспользовавшись вызовом make над
модифицированным Makefile:

\begin{minted}[fontsize=\small]{c}
calc.out: calc.l calc.y ast.h
    bison -d calc.y
    flex calc.l
    cc -o $@ calc.tab.c lex.yy.c ast.c
\end{minted}
после чего запустить.

Результат работы программы представлен на рис. \hyperref[fig:res]{2}:
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{pics/naivetest.png}
    \caption{Демонстрация работы программы}\label{fig:res}
\end{figure}

Как мы позже увидим, текущая версия значительно производительнее
версии без абстрактного синтаксического дерева.



\bibliographystyle{gost780uv}
\bibliography{source}

\end{document}